### Preguntas de Investigación y Desarrollo

1.  **El Rol de la Abstracción en el Modelado:** Explica por qué un modelo de diseño no debe intentar copiar la realidad de forma exacta. Pon un ejemplo de un atributo de una persona que sea relevante para un sistema bancario pero irrelevante para un sistema de gestión hospitalaria.
2.  **Modelado de Dominio vs. Diseño:** Compara los objetivos de un **Modelo de Dominio** y un **Modelo de Diseño**. ¿En qué momento del flujo de trabajo un analista decide añadir tipos de datos y modificadores de acceso específicos de C#?.
3.  **Análisis Lingüístico y Errores de Modelado:** Basándote en el "Caso de la Biblioteca", analiza por qué es un error común modelar acciones (verbos) como clases. ¿Qué impacto tiene este error en la estructura de métodos de un sistema?.
4.  **Impacto del Mal Encapsulamiento:** Discute las consecuencias técnicas de declarar todos los atributos como públicos (+). ¿Cómo afecta esto al **desacoplamiento** y a la integridad de la lógica de negocio según las fuentes?.
5.  **Miembros Estáticos en la Arquitectura:** Investiga la utilidad de los **miembros estáticos (static)**. ¿En qué situaciones es preferible que un dato pertenezca a la clase en sí y no a una instancia concreta? Utiliza el ejemplo de un contador de objetos para tu explicación.
6.  **Inyección de Dependencias (DI):** Evalúa las diferencias críticas entre la **inyección por constructor** y la **inyección por setter**. ¿Cuál de las dos ofrece mayor seguridad frente a excepciones de referencia nula y por qué?.
7.  **El Dilema del Ciclo de Vida (Agregación vs. Composición):** Define el concepto de "vínculo vital" en las relaciones todo-parte. ¿Cómo determinarías, basándote en el enunciado de un cliente, si una relación debe representarse con un rombo lleno o uno hueco?.
8.  **El Problema de la Herencia Múltiple:** Describe el "callejón sin salida" que presenta el caso del **Motor Híbrido** en lenguajes como C#. ¿Cómo resuelven las interfaces y la composición la limitación de no poder heredar de varias clases?.
9.  **Relaciones Muchos a Muchos (N:M):** Explica el proceso técnico para "romper" una relación de muchos a muchos. ¿Por qué es necesario crear una **clase intermedia o clase relación** cuando existen atributos que no pertenecen exclusivamente a ninguna de las dos entidades originales?.
10. **Diagram as Code con Mermaid:** Analiza las ventajas de utilizar **Mermaid.js** frente a herramientas de dibujo manuales. ¿De qué manera el principio de "Diagram as Code" facilita el trabajo colaborativo mediante sistemas de control de versiones como Git?.
11. **Ingeniería Inversa y Validación:** Describe el "Golden Path" o flujo de trabajo definitivo en Rider. ¿Por qué es fundamental contrastar el diagrama generado automáticamente por la ingeniería inversa con el diagrama de diseño original?.
12. **Principio de Sustitución de Liskov (L):** Utilizando el contraejemplo del "Pingüino que no vuela", explica cómo una jerarquía de clases mal diseñada puede romper un sistema. ¿Cuál es la solución recomendada mediante la jerarquía por capacidades?.
13. **Segregación de Interfaces (I):** ¿Qué es una "Interfaz Gorda" y qué problemas de implementación genera en clases que no requieren todos sus métodos? Propón una solución basada en **interfaces atómicas**.
14. **Inversión de Dependencias (D):** Explica cómo el uso de abstracciones (interfaces) evita que un sistema de notificaciones quede "soldado" a una tecnología específica, como el correo electrónico.
15. **Patrón Factory en Sistemas Complejos:** Justifica la implementación de una **Fábrica (Factory)** en el sistema *StarFleet Manager*. ¿Cómo ayuda este patrón a cumplir con el principio de Responsabilidad Única y a simplificar el código del cliente?.
